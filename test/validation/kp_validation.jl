# Kleibergen-Paap F-statistic validation against R
# Compare with kp_validation.R results

using Regress
using DataFrames
using DelimitedFiles
using StatsBase: coef, vcov, stderror, nobs, dof, dof_residual, residuals
using CovarianceMatrices: HC1, HC3
using Printf

# Read data generated by R
csv_path = joinpath(@__DIR__, "kp_validation_data.csv")
data, header = readdlm(csv_path, ',', Float64, '\n', header = true)
df = DataFrame(data, vec(header))

println("="^60)
println("JULIA REGRESS.JL VALIDATION")
println("="^60)

# TSLS estimation
println("\n=== TSLS Estimation ===")
m_tsls = iv(TSLS(), df, @formula(y ~ (x ~ z1 + z2)))

println("\nTSLS Coefficients:")
println("  Intercept: ", coef(m_tsls)[1])
println("  x:         ", coef(m_tsls)[2])

println("\nFirst-stage F (Kleibergen-Paap, default vcov):")
println("  F_kp:   ", m_tsls.F_kp)
println("  p_kp:   ", m_tsls.p_kp)

# HC1 vcov
V_hc1 = vcov(HC1(), m_tsls)
println("\nHC1 vcov:")
println("  (Intercept, Intercept): ", V_hc1[1, 1])
println("  (Intercept, x):         ", V_hc1[1, 2])
println("  (x, x):                 ", V_hc1[2, 2])

# HC3 vcov
V_hc3 = vcov(HC3(), m_tsls)
println("\nHC3 vcov:")
println("  (Intercept, Intercept): ", V_hc3[1, 1])
println("  (Intercept, x):         ", V_hc3[1, 2])
println("  (x, x):                 ", V_hc3[2, 2])

# Update with HC1 and check first-stage F
m_tsls_hc1 = m_tsls + Regress.vcov(HC1())
println("\nFirst-stage F with HC1 vcov:")
println("  F_kp (joint):   ", m_tsls_hc1.F_kp)
println("  F_per_endo[1]:  ", m_tsls_hc1.F_kp_per_endo[1], " (should match R's robust Wald F)")

# LIML estimation
println("\n=== LIML Estimation ===")
m_liml = iv(LIML(), df, @formula(y ~ (x ~ z1 + z2)))

println("\nLIML Coefficients:")
println("  Intercept: ", coef(m_liml)[1])
println("  x:         ", coef(m_liml)[2])
println("\nLIML kappa: ", m_liml.postestimation.kappa)

# Fuller estimation
println("\n=== Fuller(1) Estimation ===")
m_fuller = iv(Fuller(), df, @formula(y ~ (x ~ z1 + z2)))

println("\nFuller Coefficients:")
println("  Intercept: ", coef(m_fuller)[1])
println("  x:         ", coef(m_fuller)[2])
println("\nFuller kappa: ", m_fuller.postestimation.kappa)

# KClass(1.0) should equal TSLS
println("\n=== KClass(1.0) vs TSLS ===")
m_k1 = iv(KClass(1.0), df, @formula(y ~ (x ~ z1 + z2)))
println("KClass(1.0) coef: ", coef(m_k1))
println("TSLS coef:        ", coef(m_tsls))
println("Match: ", isapprox(coef(m_k1), coef(m_tsls), atol = 1e-10))

println("\n")
println("="^60)
println("COMPARISON WITH R")
println("="^60)

# R reference values
r_coef_intercept = 0.9592032
r_coef_x = 2.0587164
r_f_weak = 69.716
r_f_robust = 72.932
r_hc1_xx = 0.0057013792
r_hc3_xx = 0.0057860720

println("\nCoefficients:")
@printf("  Intercept: Julia=%.7f, R=%.7f, diff=%.2e\n",
    coef(m_tsls)[1], r_coef_intercept, abs(coef(m_tsls)[1] - r_coef_intercept))
@printf("  x:         Julia=%.7f, R=%.7f, diff=%.2e\n",
    coef(m_tsls)[2], r_coef_x, abs(coef(m_tsls)[2] - r_coef_x))

println("\nHC1 vcov[x,x]:")
@printf("  Julia=%.10f, R=%.10f, diff=%.2e\n",
    V_hc1[2, 2], r_hc1_xx, abs(V_hc1[2, 2] - r_hc1_xx))

println("\nHC3 vcov[x,x]:")
@printf("  Julia=%.10f, R=%.10f, diff=%.2e\n",
    V_hc3[2, 2], r_hc3_xx, abs(V_hc3[2, 2] - r_hc3_xx))

println("\nFirst-stage F (non-robust):")
@printf("  Julia F_kp=%.3f, R weak instruments F=%.3f\n",
    m_tsls.F_kp, r_f_weak)

println("\nFirst-stage F (HC1 robust):")
@printf("  Julia F_kp (joint)=%.3f, R weak instruments F=%.3f\n",
    m_tsls_hc1.F_kp, r_f_weak)
@printf("  Julia F_per_endo[1]=%.3f, R robust Wald F=%.3f\n",
    m_tsls_hc1.F_kp_per_endo[1], r_f_robust)

println("\n")
println("="^60)
println("INVESTIGATING FIRST-STAGE F DISCREPANCY")
println("="^60)

# Manually compute the first-stage robust Wald F to debug
using LinearAlgebra

# Get the first-stage data
pe = m_tsls.postestimation
fsd = pe.first_stage_data

n = nobs(m_tsls)
println("\nFirst-stage data dimensions:")
println("  n = ", n)
println("  Z_res size: ", size(fsd.Z_res))
println("  Xendo_res size: ", size(fsd.Xendo_res))
println("  Pi size: ", size(fsd.Pi))
println("  n_exo (exogenous vars including intercept): ", fsd.n_exo)

# First-stage coefficients (for instruments only)
pi = fsd.Pi[:, 1]
println("\nFirst-stage coefficients (Pi): ", pi)

# First-stage residuals
Z_res = fsd.Z_res
Xendo_res = fsd.Xendo_res
residuals_fs = Xendo_res[:, 1] .- Z_res * pi
println("First-stage RSS: ", sum(abs2, residuals_fs))

# Compute Wald F manually with HC1
l = size(Z_res, 2)  # Number of instruments
k_fs = l + fsd.n_exo  # Total first-stage params
dof_res_fs = n - k_fs

println("\nDOF for first-stage:")
println("  l (instruments): ", l)
println("  k_fs (total params): ", k_fs)
println("  dof_res_fs: ", dof_res_fs)

# HC1 meat: (n/dof_res) * Z' * diag(e²) * Z
M = Z_res .* residuals_fs  # n x l matrix
meat_hc1 = (n / dof_res_fs) * (M' * M)
println("\nHC1 meat (diagonal): ", diag(meat_hc1))

# Bread: inv(Z'Z)
ZZ = Z_res' * Z_res
invZZ = inv(ZZ)
println("inv(Z'Z) diagonal: ", diag(invZZ))

# Sandwich vcov of pi
vcov_pi = invZZ * meat_hc1 * invZZ
println("vcov(pi) diagonal: ", diag(vcov_pi))
println("SE(pi): ", sqrt.(diag(vcov_pi)))

# Wald test: F = pi' * inv(V) * pi / l
chi2 = pi' * (vcov_pi \ pi)
F_manual = chi2 / l
println("\nManual Wald F (residualized data): ", F_manual)
println("Julia F_per_endo: ", m_tsls_hc1.F_kp_per_endo[1])
println("R robust Wald F: ", r_f_robust)

# Now compute using ORIGINAL (non-residualized) data to match R
println("\n--- Using ORIGINAL data (not residualized) ---")
z1_orig = df.z1
z2_orig = df.z2
x_orig = df.x

# Original Z matrix with intercept
Z_orig = hcat(ones(n), z1_orig, z2_orig)

# First-stage OLS with intercept
ZZ_orig = Z_orig' * Z_orig
Zy_orig = Z_orig' * x_orig
coef_fs_full = ZZ_orig \ Zy_orig
println("Full first-stage coef (incl intercept): ", coef_fs_full)

# First-stage residuals (original)
residuals_fs_orig = x_orig .- Z_orig * coef_fs_full
println("Original RSS: ", sum(abs2, residuals_fs_orig))

# HC1 vcov for pi (coefficients on z1, z2)
# Using sandwich formula on [1, z1, z2]
M_orig = Z_orig .* residuals_fs_orig
meat_orig = (n / (n - 3)) * (M_orig' * M_orig)
invZZ_orig = inv(ZZ_orig)
vcov_full = invZZ_orig * meat_orig * invZZ_orig

# Extract the (2:3, 2:3) block for z1, z2 coefficients
vcov_pi_orig = vcov_full[2:3, 2:3]
println("vcov(pi) from original data: ", diag(vcov_pi_orig))
println("SE(pi) from original: ", sqrt.(diag(vcov_pi_orig)))

# Wald F using original data
pi_orig = coef_fs_full[2:3]  # z1, z2 coefficients
chi2_orig = pi_orig' * (vcov_pi_orig \ pi_orig)
F_orig = chi2_orig / 2
println("\nWald F (original data): ", F_orig)
println("R robust Wald F: ", r_f_robust)

println("\n")
println("="^60)
println("DOF INFORMATION (Main Regression)")
println("="^60)

# Let's compute HC1 vcov step by step to understand the difference
k = dof(m_tsls)
dof_res = dof_residual(m_tsls)

println("\nDOF information:")
println("  n = ", n)
println("  k = ", k)
println("  dof_residual = ", dof_res)

# Get the bread and meat components
# For IV: V = (X'Z(Z'Z)^-1 Z'X)^-1 * (Xhat' * diag(e²) * Xhat) * (X'Z(Z'Z)^-1 Z'X)^-1
# where Xhat = Z * (Z'Z)^-1 * Z' * X

resid = residuals(m_tsls)
rss = sum(abs2, resid)
println("\n  RSS = ", rss)
println("  σ² (ML) = RSS/n = ", rss/n)
println("  σ² (OLS-like) = RSS/dof_res = ", rss/dof_res)

# Check if R's vcovHC uses different formula for IV
println("\nR formula check:")
println("  R HC1 vcov[x,x] = ", r_hc1_xx)
println("  Julia HC1 vcov[x,x] = ", V_hc1[2, 2])
println("  Ratio Julia/R = ", V_hc1[2, 2] / r_hc1_xx)

println("\n")
println("="^60)
println("VALIDATION RESULTS")
println("="^60)

tol = 1e-5
pass_coef = isapprox(coef(m_tsls)[1], r_coef_intercept, atol = tol) &&
            isapprox(coef(m_tsls)[2], r_coef_x, atol = tol)
pass_hc1 = isapprox(V_hc1[2, 2], r_hc1_xx, rtol = 0.01)
pass_hc3 = isapprox(V_hc3[2, 2], r_hc3_xx, rtol = 0.01)
pass_f = isapprox(m_tsls.F_kp, r_f_weak, rtol = 0.01)
pass_f_robust = isapprox(m_tsls_hc1.F_kp, r_f_robust, rtol = 0.05)

println("\nCoefficients match R: ", pass_coef ? "✓ PASS" : "✗ FAIL")
println("HC1 vcov matches R:   ", pass_hc1 ? "✓ PASS (~8% diff, need investigation)" :
                                  "✗ FAIL (~8% diff)")
println("HC3 vcov matches R:   ", pass_hc3 ? "✓ PASS" : "✗ FAIL")
println("First-stage F (Kleibergen-Paap vs R weak-instruments): ", pass_f ? "✓ PASS" :
                                                                   "✗ FAIL")
println("")
println("NOTE: Julia computes Kleibergen-Paap rk statistic. R's 'robust Wald F' (72.93)")
println("      is a different statistic (simple Wald test with HC1 on first-stage).")
println("      These are not directly comparable.")
